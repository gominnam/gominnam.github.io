[ { "title": "2장 - 의미 있는 이름", "url": "/posts/clean-code-02/", "categories": "Book, Clean Code", "tags": "Clean Code, 네이밍", "date": "2022-12-17 14:33:00 +0900", "snippet": "1. 의도를 분명히 밝혀라이름을 지을 때 고려해야할 3가지 변수(혹은 함수나 클래스)의 존재 이유 수행 기능 사용 방법int elapsedTimeInDays;int daysSinceCreation;int daysSinceModification;int fileAgeInDays;//다소 길더라도 의미전달이 중요하다.//주석이 필요하다면 의도를 분명히 드러내지 못했다는 말이다.2. 발음하기 쉬운 이름을 사용하라발음하기 어려운 이름은 토론하기도 어려우며 ‘지적인’ 대화가 힘들다.Class DtaRcrd102{ private Date genymdhms; private Date modymdhms; private final String pszqint = &quot;102&quot;;}Class Customer{ private Date generationTimestmaps; private Date modificationTimestamp; private final String recordId = &quot;102&quot;;}DtaRcrd102 클래스와 리팩토링 된 Customer 클래스를 비교해 보면 프로그래머가 무엇을 선언하였는지 한눈에 알아볼 수 있으며다른사람과 코드에 대해 이야기 할 때도 한결 수월하다.3. 검색하기 쉬운 이름을 사용하라검색하기 쉬운 이름이 상수보다 좋다. //아래와 같은 코드가 숫자 4, 5로 검색하는 것보다 좋다. MAX_CLASSES_PER_STUDENT = 5; WORK_DAYS_PER_WEEK = 4;4. 클래스, 매서드 이름 클래스 이름과 객체 이름은 명사나 명사구가 적합하다.Customer, WikiPage, Account, AddressParser 등이 좋은 예시다.Manager, Processor, Data, Info 등과 같은 단어는 피하고, 동사는 사용하지 않는다. 매서드 이름은 동사나 동사구가 적합하다.postPayment, deletePage, save 등이 좋은 예다.접근자(Accessor), 변경자(Mutator), 조건자(Predicate)는 값 앞에 get, set, is를 붙인다.결이름의 어학사전만 봐도 `다른 것과 구별하기 위하여` 붙여서 부르는 말이라고 정의돼있다.그렇기에 이름은 명료해야하고, 일관적이여야한다.코드에서의 이름은 자신이 의미하는 바가 무엇인지 명확할 수록 좋다.클래스, 매서드 이름 같은 경우에는 표준에 따라 이름을 짓는 것에 익숙해져야 한다.협업하는 환경에서는 코드로 의사소통을 해야하기 때문이다.남이 술술 읽기 좋은 코드를 짜도록 하자.Clean Code에서 똑똑한 프로그래머와 전문가 프로그래머 사이에 나타나는 차이점은 `명료함`이라 한다.참고자료 Clean Code" }, { "title": "1장 - 깨끗한 코드", "url": "/posts/clean-code-01/", "categories": "Book, Clean Code", "tags": "Clean Code, 개발 철학", "date": "2022-12-13 21:40:00 +0900", "snippet": "… 글을 적기에 앞서책을 읽고 쓰는 첫 글이기 때문에 이유와 방향에 대해서 적는게 이로울듯 싶다.글을 쓰는 이유는 독서를 하고 시간이 지나 다시 회고해보면 10% 정도가 기억이 날까? 그마저도 확신이 안섰다.절망적인 기억력 때문에 정리하면서 한번더 보고, 주관적으로 중요하다 싶은 내용들을 빠르게 복기하기 위함이다.방향은 책의 내용을 정리하는 것도 있겠지만 나의 주관적인 생각, 추측하는 글도 적을 것이다. 사실 정확하지 않은 정보들을 남이 읽을 수 있기 때문에 미리 변명하기 위한 이유가 사실 가장 크다.추후에 잘못된 내용을 찾게 될시에는 수정하겠지만, 주관적인 생각과 추측은 독자가 저자에게 묻는 질문정도로 봐주면 좋겠다.읽으시면서 만약 내가 쓴 추측이 맞는지 틀린지 헷갈린다면 모르는 것이기 때문에 다른 자료를 보면서 확인하시길 바랍니다.1. 서문다음은 서문에서 좋은 개발자가 되기위한 마음가짐과 철학에 대해 생각하는 좋은 글귀라 생각한다.- 많이 고민하고 생각하는 만큼 여러분의 프로그래밍 실력이 늘어나리라- 생각하고 계획할 시간을 확보하기- 장인 정신- 깨끗한 코드를 작성하는 방법을 배우는 것에 고생을 해야한다.2. 1장 깨끗한 코드코드?- 코드는 요구사항을 상세히 표현하는 수단이다. 이 사실을 명심한다.- 기계가 실행할 정도로 상세하게 요구사항을 명시하는 작업, 바로 이것이 프로그래밍이다. 이렇게 명시한 결과가 바로 코드다. * 코드를 대하는 태도- 나중에 돌아와 코드를 정리한다는 생각을 버리자. 나중은 결코 오지 않는다.(르블랑의 법칙)- 빨리 가는 유일한 방법은, 언제나 코드를 최대한 깨끗하게 유지하는 습관이다.깨끗한 코드란?키워드 - 우아한, 효율, 가독성(문학적), 작을수록 좋다, 중복이 없다근거 - 코드를 읽는 시간 대 코드를 짜는 시간 비율이 10대 1을 훌쩍 넘는다.방법 - 변수 이름을 개선하고, 긴 함수 하나를 분할하고, 약간의 중복을 제거하고, 복잡한 if문 하나를 정리하자. 결 - 후기좋은 프로그래머가 되려면 코드를 대하는 자세를 예술가처럼 해야한다.악기를 코드, 피아니스트를 프로그래머에 비유하면 알맞아 보인다.피아니스트는 청중이 듣기 좋은 소리를 내기위해서 끊임없이 악보를 분석하고 피아노를 치는 연습을 한다.자신의 만족뿐만 아니라 남들이 귀기울이는 소리또한 아름다워야 좋은 아티스트라 할 수 있을 것이다.참고자료 Clean Code" }, { "title": "JBoss? Tomcat?", "url": "/posts/JBoss/", "categories": "Study, Etc", "tags": "spring, server", "date": "2022-09-05 21:20:00 +0900", "snippet": "JBoss? Tomcat?Red Hat의 JBoss와 Apache의 Tomcat 플랫폼은 가장 광범위하게 사용되는 자바 어플리케이션 서버이다.두 서버 모두 개발 및 프로덕션을 관리할 수 있다. 어느 플랫폼이 적합한지 비교하며 장점과 단점을 정리해야겠다.JBoss와 Tomcat을 비교할 때 지원하는 Java API를 포함하여 여러가지를 비교해야 하지만 주요한 차이점은 JBoss는 애플리케이션 서버인 반면 Tomcat은 서블릿 컨테이너이자 웹 서버라는 것이다.위의 차이를 간략하게 정리하자면, WAS(Web Application Server)는 Java EE 사양을 준수하여 만든 서버를 의미하는데 좀 더 기능이 추가된 환경을 제공한다.이미지출처 - https://www.tibco.com/reference-center/what-is-batch-processing비즈니스에 적용 시 고려사항 대량건의 데이터를 처리한다. 특정 시간에 자동 실행된다. 잘못된 데이터를 충돌/중단 없이 처리할 수 있어야 한다. 일괄적으로 처리한다.일괄 처리의 좋은 예로는 신용 카드 회사의 청구 방식이 있다. 고객이 신용 카드 청구서를 받을 때 각 거래에 대한 별도의 청구서가 아니라 한 달 전체에 대한 하나의 청구서를 발행하기 때문에 일괄 처리를 사용하여 생성한다. 해당 월의 모든 거래들을 특정 날짜에 한꺼번에 처리한다.일괄처리를 사용하는 이유컴퓨터 리소스가 제한되어 있기 때문에 오늘날의 많은 데이터들을 하루가 끝날 때(업무시간이 아닐 때) 배치를 실행하여 귀중한 리소스들이 묶여있지 않고 효율적으로 대량 데이터들을 처리할 수 있다.그러므로 빠른 속도로 업무를 처리하고, 비용을 절감할 수 있다.Spring에서의 BatchSpring Batch는 Spring의 특성을 그대로 사용하기 때문에 DI(Dependency Injection) - 의존성주입 AOP(Aspect Oriented Programming) - 관점지향프로그래밍 Abstraction - 추상화위의 특성을 갖는다.Batch? Quartz?Quartz의 강점은 스케쥴러 기능을 Batch 강점은 대용량 데이터 처리이기 때문에보통은 Quartz와 Batch를 조합하여 사용한다.참고자료 https://cloudinfrastructureservices.co.uk/tomcat-vs-jboss-whats-the-difference/" }, { "title": "배치파일 - Batch File", "url": "/posts/batch/", "categories": "Study, Etc", "tags": "spring, batch", "date": "2022-08-29 18:20:00 +0900", "snippet": "배치 파일(Batch File)이란?배치파일(Batch File)은 마이크로소프트사의 DOS 운영체제인 MS-DOS에서 명령어를 치는게 익숙치 않은 사용자들을 위해명령어를 한번에 적어놓고 실행하게 할 수 있게 만들어서 편리하게 사용자가 타이핑 치는 수고를 줄여 놓은 명령어 스크립트이다..bat 혹은 .cmd 형식의 확장자 파일을 직접 실행하거나 명령 프롬프트에서 배치 파일의 이름으로 실행할 수 있다.특히 배치파일은 서버 분야에서 DB 관리와 백업 등에서 많이 사용된다. 또한 위도우 스케쥴러 등을 이용해 다소 반복적이고 귀찮은 업무를 자동화하는 데 많이 사용된다.이런 전문적인 업무 외에도 많은 게임들에서 서버 운영을 하는 것에 배치 파일을 많이 사용하고 게임 실행 등에도 사용된다.이미지출처 - https://www.tibco.com/reference-center/what-is-batch-processing비즈니스에 적용 시 고려사항 대량건의 데이터를 처리한다. 특정 시간에 자동 실행된다. 잘못된 데이터를 충돌/중단 없이 처리할 수 있어야 한다. 일괄적으로 처리한다.일괄 처리의 좋은 예로는 신용 카드 회사의 청구 방식이 있다. 고객이 신용 카드 청구서를 받을 때 각 거래에 대한 별도의 청구서가 아니라 한 달 전체에 대한 하나의 청구서를 발행하기 때문에 일괄 처리를 사용하여 생성한다. 해당 월의 모든 거래들을 특정 날짜에 한꺼번에 처리한다.일괄처리를 사용하는 이유컴퓨터 리소스가 제한되어 있기 때문에 오늘날의 많은 데이터들을 하루가 끝날 때(업무시간이 아닐 때) 배치를 실행하여 귀중한 리소스들이 묶여있지 않고 효율적으로 대량 데이터들을 처리할 수 있다.그러므로 빠른 속도로 업무를 처리하고, 비용을 절감할 수 있다.Spring에서의 BatchSpring Batch는 Spring의 특성을 그대로 사용하기 때문에 DI(Dependency Injection) - 의존성주입 AOP(Aspect Oriented Programming) - 관점지향프로그래밍 Abstraction - 추상화위의 특성을 갖는다.Batch? Quartz?Quartz의 강점은 스케쥴러 기능을 Batch 강점은 대용량 데이터 처리이기 때문에보통은 Quartz와 Batch를 조합하여 사용한다.참고자료 https://en.wikipedia.org/wiki/Batch_file https://www.tibco.com/reference-center/what-is-batch-processing" }, { "title": "토이프로젝트 - WebSocket", "url": "/posts/api-websocket/", "categories": "Project, chatting", "tags": "project, websocket", "date": "2022-07-26 20:11:00 +0900", "snippet": "채팅서버를 구현하기 앞서 서버환경을 어떻게 해야할지 자료를 조사하던중 기존에 구현해봤던 API대신에 WebSocket이라는 것을 사용해야한다.WebSocket은 사용자의 브라우저와 서버간에 단일 TCP 연결을 통해 전이중 통신 채널을 제공하는 컴퓨터 통신 프로토콜이다. 이 API를 사용하면 응답을 위해 서버를 폴링(Polling)하지 않고 서버에 메세지를 보내고 이벤트 기반 응답을 받을 수 있다.접속까지는 HTTP 프로토콜을 이용하고 그 이후의 통신은 자체적은 WebSocket 프로토콜으로 통신하게 된다.용어정리 폴링(Polling) : 폴링(polling)이란 하나의 장치(또는 프로그램)이 충돌 회피 또는 동기화 처리 등을 목적으로 다른 장치(또는 프로그램)의 상태를 주기적으로 검사하여 일정한 조건을 만족할 때 송수신 등의 자료처리를 하는 방식을 말한다.참고자료 https://www.educba.com/websocket-vs-rest/ https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API https://daddyprogrammer.org/post/4077/spring-websocket-chatting/" }, { "title": "토이프로젝트 - 채팅 환경", "url": "/posts/start/", "categories": "Project, chatting", "tags": "project", "date": "2022-07-04 21:23:00 +0900", "snippet": "프로젝트 설명채팅기능을 구현한 간단한 토이프로젝트를 시작하려고 한다.서로 다른 네트워크 환경에서 웹소켓을 기반으로 통신을 주고받을 수 있는 기능을 먼저 구현하려고 한다.프로젝트를 진행하면서 지속적으로 개요 글인 이 글을 업데이트를 할 예정이다.개발환경은 아래와 같다. Java Mac OS, IntelliJ github: https://github.com/gominnam/toy-chat" }, { "title": "자료구조 - Linked List", "url": "/posts/linked-list/", "categories": "Study, Data Structure", "tags": "data structure, linked list", "date": "2022-06-28 01:26:00 +0900", "snippet": "링크드 리스트(Linked List)는 추상적 자료형인 리스트를 구현한 자료구조로 동적으로 크기가 변할 수 있고 삭제나 삽입 시에 데이터를 이동할 필요가 없는 연결된 표현이다. 이 연결은 포인터를 사용하여 데이터들을 연결한다.이 연결된 표현은 사실 추상 데이터 타입 리스트의 구현에만 사용되는 것이 아니고 여러 가지의 자료구도(트리, 그래프, 스택, 큐) 등을 구현하는데도 많이 사용된다.위 그림에서 1, 2, 3, 4, 5 숫자는 데이터를 넣고 연결된 표현은 숫자 옆의 줄로 연결됐다고 생각하면 되겠다.링크드 리스트는 데이터를 한군데 모아두는 것을 포기하고 메모리상의 어디에나 흩어져 존재하게 되는데 연결하는 줄(pointer)로 묶음으로써 리스트를 구현한다.링크드 리스트 구조연결 리스트는 위 그림과 같이 노드(node)들의 집합이다. 노드들은 메모리의 어떤 위치에나 있을 수 있으며 다른 노드로 가기 위해서는 현재 노드가 가지고 있는 포인터를 이용하면 된다.노드는 위 그림과 같이 데이터 필드(data)와 링크 필드(next)로 구성되어 있다. 데이터 필드에는 저장하고 싶은 데이터가 들어가고, 링크 필드에는 다른 노드를 가리키는 포인터가 저장된다.따라서 연결 리스트마다 첫 번째 노드를 가리키고 있는 변수가 필요한데 이것을 헤드 포인터(head pointer)라고 한다.마지막 노드의 링크 필드는 NULL으로 설정되는데 이는 더 이상 연결된 노드가 없다는 것을 의미한다.링크드 리스트 특징 배열보다 데이터를 중간에 삽입, 삭제시 더 용이하다. 상대적으로 구현이 더 어렵고 오류가 나기 쉽다. 데이터뿐만 아니라 포인터도 저장하여야 하므로 메모리 공간을 많이 사용한다.링크드 리스트 종류 단순 연결 리스트(singly linked list)는 하나의 방향으로만 연결되어 있는 연결 리스트이다. 원형 연결 리스트(circular linked list)는 단순 연결 리스트와 같으나 마지막 노드의 링크가 첫 번째 노드를 가리킨다. 이중 연결 리스트(doubly linked list)는 각 노드마다 2개의 링크가 존재한다. Source Codepublic class LinkedList{ Node header; public static class Node{ int data; Node next; } //initialization **header LinkedList(){ header = new Node(); } //append Node public void append(int data){ Node end = new Node(); end.data = data; Node n = header; while(n.next != null){ n = n.next; } n.next = end; } //delete Node public void delete(int data){ Node n = header; while(n.next != null){ if(n.next.data == data){ n.next = n.next.next; } else { n = n.next; } } } //print LinkedList datas public void retrieve(){ Node n = header; while(n.next != null){ n = n.next; System.out.println(n.data); } System.out.println(n.data); } //double pointer public void removeDups(){ Node n1 = header; while(n1 != null &amp;amp;&amp;amp; n1.next != null){ Node n2 = n1; while(n2.next != null){ if(n1.data == n2.next.data){ n2.next = n2.next.next; } else{ n2 = n2.next; } } n1 = n1.next; } }}//원형연결리스트의 경우 마지막 노드의 링크가 첫번째 노드를 가르키는 소스를 추가하면 된다.//이중연결리스트의 경우 각 노드마다 링크 2개를 선언하여(prev, next) 서로를 가르키는 소스를 추가하면 된다.참고자료 https://namu.wiki/w/%EC%97%B0%EA%B2%B0%20%EB%A6%AC%EC%8A%A4%ED%8A%B8 https://www.andrew.cmu.edu/course/15-121/lectures/Linked%20Lists/linked%20lists.html#:~:text=The%20entry%20point%20into%20a,is%20a%20dynamic%20data%20structure. https://www.programiz.com/dsa/linked-list-types C언어로 쉽게 풀어쓴 자료구조 - 생능출판" }, { "title": "디자인패턴 - Bridge Pattern", "url": "/posts/bridge-pattern/", "categories": "Design Pattern, Structural", "tags": "design pattern, bridge", "date": "2022-06-21 18:47:00 +0900", "snippet": "브릿지(Bridge)패턴은 구현부에서 추상층을 분리하여 각자 독립적으로 변형하여 밀접하게 관련된 클래스 집합을 서로 독립적으로 개발할 수 있게 하는 구조 패턴이다.이미지출처 - https://refactoring.guru/design-patterns/bridge적용 시 고려사항 두 클래스가 동일하거나 유사한 작업을 수행하지만 인터페이스가 다른경우 두 클래스가 공통 인터페이스를 가지면, 클라이언트 코드가 더 간단하고 명료해질 수 있는 경우 외부 라이브러리라서 인터페이스를 바꾸고 싶어도 쉽게 바꿀 수 없는 경우, 또는 소스코드를 갖고 있지 않는 경우UML 클래스 다이어그램이미지출처 - https://refactoring.guru/design-patterns/bridge상점에 패턴을 적용해 구현해봤습니다.인터페이스(Implementation)public interface Service { public void deal(); public void guide();}인터페이스 구현(Concrete)//키오스크 판매public class Kiosk implements Service{ @Override public void deal(){ System.out.println(&quot;kiosk.. sale completed!&quot;); } @Override public void guide(){ System.out.println(&quot;kiosk.. showing sales list..&quot;); }}//직원 판매public class Employee implements Service{ @Override public void deal(){ System.out.println(&quot;employee sale completed!&quot;); } @Override public void guide(){ System.out.println(&quot;employee recommend a product&quot;); }}추상클래스(Abstraction)public abstract class Store { protected Service service; public Store(Service service){ this.service = service; } public abstract void sale();}추상클래스 구현(Refined Abstraction)//무인판매점public class UnmannedStore extends Store{ public UnmannedStore(Service service) { super(service); } @Override public void sale(){ service.guide(); service.deal(); }}//유인판매점public class MannedStore extends Store{ public MannedStore(Service service) { super(service); } public void sale(){ service.guide(); service.deal(); }}클라이언트(Client)public class Client { public static void main(String[] args){ Store unmannedStore = new UnmannedStore(new Kiosk()); Store mannedStore = new MannedStore(new Employee()); unmannedStore.sale(); System.out.println(&quot;-----------------------------------------&quot;); mannedStore.sale(); }}실행 결과장점 구현에서 추상을 분리하여, 이들이 독립적으로 다양성을 가질 수 있도록 한다. 지속적인 종속 관계를 피할 수 있다. 확장성이 향상된다. 클라이언트로부터 구현 정보 은닉.단점 디자인이 복잡하다.참고자료 https://refactoring.guru/design-patterns/bridge https://en.wikipedia.org/wiki/Bridge_pattern GoF 디자인 패턴" }, { "title": "디자인패턴 - Adapter Pattern", "url": "/posts/adapter-pattern/", "categories": "Design Pattern, Behavioral", "tags": "design pattern, adapter", "date": "2022-06-19 16:26:00 +0900", "snippet": "어댑터(Adapter) 패턴은 호환되지 않는 인터페이스를 가진 개체들이 서로 협업할 수 있도록 하는 패턴 구조이다.다음 조건을 모두 만족한다면 어댑터 패턴으로 리팩토링하는 것이 좋다.어댑터 구현에는 오브젝트-어댑터와 클래스-어댑터(다중상속)가 있지만 JAVA는 다중상속이 안되므로 오브젝트-어댑터만 정리해보려고 한다.적용 시 고려사항 두 클래스가 동일하거나 유사한 작업을 수행하지만 인터페이스가 다른경우 두 클래스가 공통 인터페이스를 가지면, 클라이언트 코드가 더 간단하고 명료해질 수 있는 경우 외부 라이브러리라서 인터페이스를 바꾸고 싶어도 쉽게 바꿀 수 없는 경우, 또는 소스코드를 갖고 있지 않는 경우UML 클래스 다이어그램이미지출처 - https://refactoring.guru/design-patterns/adapter변압기를 주제로 어댑터 패턴을 적용해 소스를 구현해봤습니다.인터페이스//220볼트 인터페이스interface Volt220 { public void connect();}//110볼트 인터페이스public interface Volt110 { public void connect(); }인터페이스 상속(Adaptee)//220볼트 드라이기public class HairDryer220V implements Volt220 { @Override public void connect() { System.out.println(&quot;220V connection success!&quot;); } public void dry() { System.out.println(&quot;activating 220v hair-dryer&quot;); }}//110볼트 드라이기public class HairDryer110V implements Volt110 { @Override public void connect() { System.out.println(&quot;110V connection success!&quot;); } public void dry() { System.out.println(&quot;activating 110v hair-dryer&quot;); }}어댑터(Adapter)//100볼트 드라이기 220볼트 어댑터class SetUpTransformer implements Volt220 { Volt110 volt110; public SetUpTransformer(Volt110 volt) { this.volt110 = volt; } @Override public void connect() { volt110.connect(); } public void dry() { System.out.println(&quot;activating 110v to 220v hair-dryer&quot;); }}사용자public class Client { public static void main(String[] args){ HairDryer110V hD110V = new HairDryer110V(); SetUpTransformer sut110to220 = new SetUpTransformer(hD110V); sut110to220.connect(); sut110to220.dry(); }}실행 결과장점 기존에 사용하던 코드를 수정하지 않아도 된다. 상속이 아닌 구성(Composition)을 이용하기 때문에 Adaptee의 모든 서브클래스에 대해 어댑터를 사용할 수 있다. 인터페이스 호환성 때문에 같이 쓸 수 없는 클래스들을 연결해서 쓸 수 있다.단점 Adaptee객체를 만들어야 한다.참고자료 https://refactoring.guru/design-patterns/adapter GoF 디자인 패턴" }, { "title": "자료구조 - Stack", "url": "/posts/stack/", "categories": "Study, Data Structure", "tags": "data structure, stack", "date": "2022-06-17 12:55:12 +0900", "snippet": "스택(Stack)은 큐와 반대로 LIFO(Last In First Out) 즉, 후입선출 원칙을 따르는 선형 데이터 구조이다.시간복잡도는 Array로 구현했을 경우 push, pop 작업이 O(1)이다.위 그림에서 1번, 2번, 3번이 순서대로 데이터가 쌓이고(push) 꺼낼 때는 위에 쌓인 3번, 2번, 1번 순서로 갖고온다(pop).실제 사용되는 예시로는 컴파일러 연산처리, 웹 브라우저 뒤로가기(undo), 전화 리다이얼 기능 등이 있다.Source Code기본적인 스택 구현 소스코드이다.import java.util.NoSuchElementException;public class Stack&amp;lt;T&amp;gt;{ private Node&amp;lt;T&amp;gt; top; class Node&amp;lt;S&amp;gt;{ private S data; private Node&amp;lt;S&amp;gt; next; public Node(S data){ this.data = data; } } //가장 위에 쌓인 데이터를 반환 public T pop(){ if(top == null){ throw new EmptyStackException(); } T item = top.data; top = top.next; return item; } //가장 위에 데이터 쌓기 public void push(T item){ Node&amp;lt;T&amp;gt; n = new Node&amp;lt;&amp;gt;(item); n.next = top; top = n; } //가장 위에 쌓인 데이터 확인 public T peek(){ if(top == null){ throw new EmptyStackException(); } return top.data; } //데이터가 비어있는지 확인 public boolean isEmpty(){ return top == null; }}참고자료 https://www.programiz.com/dsa/stack" }, { "title": "데이터베이스 - VIEW", "url": "/posts/view/", "categories": "Study, Database", "tags": "database, sql, view", "date": "2022-06-14 18:08:00 +0900", "snippet": " View 란? View 예시코드View 란?SQL에서 뷰(View)란 데이터베이스에서 쿼리의 결과를 가상 테이블로써 사용할 수 있게 한다.딕셔너리에 뷰 테이블의 SQL(쿼리)을 저장하여 사용하기 때문에 디스크 공간을 따로 할애하지 않는다.(딕셔너리 뷰)VIEW 장점 직접 테이블에 접근하는 것이 아니므로 사용자가 필요한 부분만 선택하여 만들 수 있다.(가상테이블) 사용자별로 접근 권한을 지정할 수 있고, 수정.삭제 등을 하지 못하기 때문에 보안에 유리하다. 각기 다른 데이터베이스 시스템에서 데이터를 전달해야 할 경우 복잡한 SQL문이 반복적으로 사용될 경우 효율적이다. 저장공간을 사용하지 않으므로 자원사용에서 효율적이다.View 문법[ ORACLE ]//VIEW 생성CREATE OR REPLACE VIEW [스키마.][뷰 NAME] ASSELECT문;//VIEW 수정(생성된 뷰 이름을 뷰 NAME에 사용)CREATE OR REPLACE VIEW [스키마.][뷰 NAME] ASSELECT문;//VIEW 삭제DROP VIEW [스키마.][뷰 NAME]//VIEW 구조확인DESC [스키마.][뷰 NAME];View 예시코드[ ORACLE ]//VIEW 생성CREATE OR REPLACE VIEW V_STUDENT ASSELECT S.NAME, S.GRADE, S.GENDER FROM STUDENT S;//VIEW 수정CREATE OR REPLACE VIEW V_STUDENT ASSELECT S.NAME, S.GRADE, S.GENDER, T.NAME AS TEACHERFROM STUDENT SLEFT OUTER JOIN TEACHER T ON S.CLASS = T.CLASS;//VIEW 삭제DROP VIEW V_STUDENT;//VIEW 구조확인DESC V_STUDENT;참고자료 https://en.wikipedia.org/wiki/View_(SQL) https://coding-factory.tistory.com/417" }, { "title": "디자인패턴 - Factory Method Pattern", "url": "/posts/factory-method-pattern/", "categories": "Design Pattern, Creational", "tags": "design pattern, factory method", "date": "2022-06-10 16:26:00 +0900", "snippet": "팩토리 매소드 패턴이란 생성될 객체의 정확한 클래스를 지정하지 않고 인스턴스를 생성하기 위해 사용하는 패턴이다.생성자를 호출하는 대신 인터페이스로 지정하고 자식 클래스 또는 기본 클래스에 구현하여 재정의된 매소드를 호출하여 선택적으로 객체를 생성할 수 있다.적용 시 고려사항 어떤 클래스가 자신이 생성해야 하는 객체의 클래스를 `예측할 수 없을 때` 생성할 객체를 기술하는 책임을 자신의 서브클래스가 지정했으면 할 때 객체 생성의 책임을 몇 개의 보조 서브클래스 가운데 하나에게 위임하고, 어떤 서브클래스가 위임자인지에 대한 정보를 국소화시키고 싶을 때UML 클래스 다이어그램 Creator : 팩토리 매서드를 구현하는 클래스 ConcreteCreator : 팩토리 매서드를 구현하는 클래스로 concreteProduct 객체를 생성 Product : 팩토리 매서드로 생성될 객체의 공통 인터페이스 ConcreteProduct : 구체적으로 객체가 생성되는 클래스Product//Super Classpublic abstract class Computer { public abstract String getRam(); public abstract String getCpu(); public abstract String getHdd(); public abstract String toString();}ConcreteProduct//Product PCpublic class PC extends Computer{ private String ram; private String cpu; private String hdd; public PC(String ram, String cpu, String hdd){ this.ram = ram; this.cpu = cpu; this.hdd = hdd; } @Override public String getRam(){ return this.ram; } @Override public String getCpu(){ return this.cpu; } @Override public String getHdd(){ return this.hdd; } @Override public String toString(){ return &quot;this is PC info : cpu=&quot; + getCpu() + &quot;, ram=&quot; + getRam() + &quot;, hdd=&quot; + getHdd(); }}//Product Serverpublic class Server extends Computer{ private String ram; private String cpu; private String hdd; public Server(String ram, String cpu, String hdd){ this.ram = ram; this.cpu = cpu; this.hdd = hdd; } @Override public String getRam(){ return this.ram; } @Override public String getCpu(){ return this.cpu; } @Override public String getHdd(){ return this.hdd; } @Override public String toString(){ return &quot;this is Server info : cpu=&quot; + getCpu() + &quot;, ram=&quot; + getRam() + &quot;, hdd=&quot; + getHdd(); }}ConcreteCreator//Factory Class (Singleton으로 구현해도 되고, 서브클래스를 리턴하는 static 메소드로 구현해도 된다.)public class ComputerFactory { public static Computer getComputer(String type, String ram, String cpu, String hdd){ if(&quot;PC&quot;.equalsIgnoreCase(type)) return new PC(ram, cpu, hdd); else if(&quot;Server&quot;.equalsIgnoreCase(type)) return new Server(ram, cpu, hdd); else throw new IllegalArgumentException(&quot;Unknown Type : &quot; + type); }}Creatorpublic class Factory { public static void main(String[] args){ Computer pc = ComputerFactory.getComputer(&quot;PC&quot;, &quot;pcRam&quot;, &quot;pcCpu&quot;, &quot;pcHdd&quot;); Computer server = ComputerFactory.getComputer(&quot;Server&quot;, &quot;svRam&quot;, &quot;svCpu&quot;, &quot;svHdd&quot;); System.out.println(pc); System.out.println(server); }}실행 결과장점 팩토리 패턴은 클라이언트 코드로부터 서브클래스의 인스턴스화를 제거하여 서로 간의 종속성을 낮추고, 결합도를 느슨하게 하며, 확장을 쉽게 합니다. 팩토리 패턴은 클라이언트와 구현 객체들 사이에 추상화를 제공합니다. 인스턴스 예측 불가능할 때 사용한다. 즉, 어떤 인스턴스를 생성할지 서브클래스가 결정을 내린다.(캡슐화 패턴)참고자료 https://en.wikipedia.org/wiki/Factory_method_pattern GoF 디자인 패턴" }, { "title": "자료구조 - Queue", "url": "/posts/queue/", "categories": "Study, Data Structure", "tags": "data structure, queue", "date": "2022-06-08 20:08:00 +0900", "snippet": "큐(Queue)는 프로그래밍에서 사용되는 기본적인 자료구조의 한가지이다.큐의 특징은 데이터를 집어넣은 순서대로 나오는 FIFO(Fisrt In First Out) 구조로 저장하는 방식을 갖는다.나중에 작성하겠지만, 자료구조 스택(Stack)과는 반대되는 개념이다.위의 사진에서 Enqueue 방향으로 데이터가 쌓이고 Dequeue에서 쌓인 순서대로 데이터가 빠져나간다.널리 쓰이는 예시는 식당앞에 줄을 선 사람들, 은행 창구 대기번호가 있다.Source Code기본적인 큐 구현 소스코드이다.import java.util.NoSuchElementException;public class Queue&amp;lt;T&amp;gt;{ class Node&amp;lt;Q&amp;gt;{ private Q data; private Node&amp;lt;Q&amp;gt; next; public Node(Q data){ this.data = data; } } private Node&amp;lt;T&amp;gt; first; private Node&amp;lt;T&amp;gt; last; public void add(T item){//enqueue Node&amp;lt;T&amp;gt; t = new Node&amp;lt;&amp;gt;(item); if(last != null){ last.next = t; } last = t; if(first == null){ first = last; } } public T remove(){//dequeue if(first == null){ throw new NoSuchElementException(); } T data = first.data; first = first.next; if(first == null){ last = null; } return data; } public T peek(){ if(first == null){ throw new NoSuchElementException(); } return first.data; } public boolean isEmpty(){ return first == null; }}참고자료 https://en.wikipedia.org/wiki/Queue_(abstract_data_type)" } ]
